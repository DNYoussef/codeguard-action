diff --git a/src/jinja2/sandbox.py b/src/jinja2/sandbox.py
index 9c9dae2..8200195 100644
--- a/src/jinja2/sandbox.py
+++ b/src/jinja2/sandbox.py
@@ -8,7 +8,6 @@ import typing as t
 from _string import formatter_field_name_split  # type: ignore
 from collections import abc
 from collections import deque
-from functools import update_wrapper
 from string import Formatter
 
 from markupsafe import EscapeFormatter
@@ -84,6 +83,20 @@ _mutable_spec: t.Tuple[t.Tuple[t.Type[t.Any], t.FrozenSet[str]], ...] = (
 )
 
 
+def inspect_format_method(callable: t.Callable[..., t.Any]) -> t.Optional[str]:
+    if not isinstance(
+        callable, (types.MethodType, types.BuiltinMethodType)
+    ) or callable.__name__ not in ("format", "format_map"):
+        return None
+
+    obj = callable.__self__
+
+    if isinstance(obj, str):
+        return obj
+
+    return None
+
+
 def safe_range(*args: int) -> range:
     """A range that can't generate ranges with a length of more than
     MAX_RANGE items.
@@ -303,9 +316,6 @@ class SandboxedEnvironment(Environment):
                     except AttributeError:
                         pass
                     else:
-                        fmt = self.wrap_str_format(value)
-                        if fmt is not None:
-                            return fmt
                         if self.is_safe_attribute(obj, argument, value):
                             return value
                         return self.unsafe_undefined(obj, argument)
@@ -323,9 +333,6 @@ class SandboxedEnvironment(Environment):
             except (TypeError, LookupError):
                 pass
         else:
-            fmt = self.wrap_str_format(value)
-            if fmt is not None:
-                return fmt
             if self.is_safe_attribute(obj, attribute, value):
                 return value
             return self.unsafe_undefined(obj, attribute)
@@ -341,49 +348,34 @@ class SandboxedEnvironment(Environment):
             exc=SecurityError,
         )
 
-    def wrap_str_format(self, value: t.Any) -> t.Optional[t.Callable[..., str]]:
-        """If the given value is a ``str.format`` or ``str.format_map`` method,
-        return a new function than handles sandboxing. This is done at access
-        rather than in :meth:`call`, so that calls made without ``call`` are
-        also sandboxed.
+    def format_string(
+        self,
+        s: str,
+        args: t.Tuple[t.Any, ...],
+        kwargs: t.Dict[str, t.Any],
+        format_func: t.Optional[t.Callable[..., t.Any]] = None,
+    ) -> str:
+        """If a format call is detected, then this is routed through this
+        method so that our safety sandbox can be used for it.
         """
-        if not isinstance(
-            value, (types.MethodType, types.BuiltinMethodType)
-        ) or value.__name__ not in ("format", "format_map"):
-            return None
-
-        f_self: t.Any = value.__self__
-
-        if not isinstance(f_self, str):
-            return None
-
-        str_type: t.Type[str] = type(f_self)
-        is_format_map = value.__name__ == "format_map"
         formatter: SandboxedFormatter
-
-        if isinstance(f_self, Markup):
-            formatter = SandboxedEscapeFormatter(self, escape=f_self.escape)
+        if isinstance(s, Markup):
+            formatter = SandboxedEscapeFormatter(self, escape=s.escape)
         else:
             formatter = SandboxedFormatter(self)
 
-        vformat = formatter.vformat
-
-        def wrapper(*args: t.Any, **kwargs: t.Any) -> str:
-            if is_format_map:
-                if kwargs:
-                    raise TypeError("format_map() takes no keyword arguments")
-
-                if len(args) != 1:
-                    raise TypeError(
-                        f"format_map() takes exactly one argument ({len(args)} given)"
-                    )
-
-                kwargs = args[0]
-                args = ()
+        if format_func is not None and format_func.__name__ == "format_map":
+            if len(args) != 1 or kwargs:
+                raise TypeError(
+                    "format_map() takes exactly one argument"
+                    f" {len(args) + (kwargs is not None)} given"
+                )
 
-            return str_type(vformat(f_self, args, kwargs))
+            kwargs = args[0]
+            args = ()
 
-        return update_wrapper(wrapper, value)
+        rv = formatter.vformat(s, args, kwargs)
+        return type(s)(rv)
 
     def call(
         __self,  # noqa: B902
@@ -393,6 +385,9 @@ class SandboxedEnvironment(Environment):
         **kwargs: t.Any,
     ) -> t.Any:
         """Call an object from sandboxed code."""
+        fmt = inspect_format_method(__obj)
+        if fmt is not None:
+            return __self.format_string(fmt, args, kwargs, __obj)
 
         # the double prefixes are to avoid double keyword argument
         # errors when proxying the call.
diff --git a/tests/test_security.py b/tests/test_security.py
index 864d5f7..9c7c442 100644
--- a/tests/test_security.py
+++ b/tests/test_security.py
@@ -173,20 +173,3 @@ class TestStringFormatMap:
             '{{ ("a{x.foo}b{y}"|safe).format_map({"x":{"foo": 42}, "y":"<foo>"}) }}'
         )
         assert t.render() == "a42b&lt;foo&gt;"
-
-    def test_indirect_call(self):
-        def run(value, arg):
-            return value.run(arg)
-
-        env = SandboxedEnvironment()
-        env.filters["run"] = run
-        t = env.from_string(
-            """{% set
-                ns = namespace(run="{0.__call__.__builtins__[__import__]}".format)
-            %}
-            {{ ns | run(not_here) }}
-            """
-        )
-
-        with pytest.raises(SecurityError):
-            t.render()
