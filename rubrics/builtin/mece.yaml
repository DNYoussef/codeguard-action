# MECE Rubric (Mutually Exclusive, Collectively Exhaustive)
# Based on the McKinsey consulting framework
#
# MECE ensures:
# - Mutually Exclusive: No overlap between categories
# - Collectively Exhaustive: All cases covered
#
# Applied to code, this detects:
# - Duplicate logic
# - Overlapping conditionals
# - Missing edge cases
# - Redundant implementations

name: mece
version: "1.0"
description: "MECE analysis for detecting duplication and gaps in code coverage"

thresholds:
  uniqueness_score: 0.80  # Minimum 80% unique code
  duplication_tolerance: 0.15  # Maximum 15% duplication

rules:
  # Mutual Exclusivity Violations (Overlap)
  - id: MECE-001
    name: duplicate_function_logic
    category: duplication
    severity: medium
    description: "Detect functions with similar logic that could be consolidated"
    guidance: |
      Consolidate duplicate logic:
      - Extract common patterns to shared functions
      - Use inheritance or composition
      - Apply DRY (Don't Repeat Yourself)
      - Similarity threshold: 70%
    similarity_threshold: 0.70

  - id: MECE-002
    name: overlapping_conditionals
    category: overlap
    severity: high
    description: "Detect overlapping conditional branches"
    guidance: |
      Conditionals should be mutually exclusive:
      - Use elif instead of multiple if when appropriate
      - Check for overlapping ranges
      - Consider exhaustive pattern matching
    patterns:
      - "if\\s+[a-z_]+\\s*[<>=]+.*\\n\\s*if\\s+[a-z_]+\\s*[<>=]+"

  - id: MECE-003
    name: redundant_type_checks
    category: overlap
    severity: medium
    description: "Detect redundant isinstance or type checks"
    guidance: |
      Type checks should not overlap:
      - Check parent classes only once
      - Use union types instead of multiple checks
      - Consider Protocol-based duck typing
    patterns:
      - "isinstance\\([^,]+,\\s*\\([^)]+\\)\\)"
      - "type\\([^)]+\\)\\s*==\\s*type\\([^)]+\\)"
      - "typeof\\s+\\w+\\s*===.*typeof\\s+\\w+\\s*==="
      - "instanceof\\s+\\w+.*instanceof\\s+\\w+"

  - id: MECE-004
    name: duplicate_error_handling
    category: duplication
    severity: low
    description: "Detect duplicate exception handling blocks"
    guidance: |
      Consolidate error handling:
      - Use exception hierarchies
      - Create custom exception classes
      - Centralize error recovery logic
    patterns:
      - "except\\s+[A-Za-z]+Error:.*\\n(?:.*\\n){0,5}.*except\\s+[A-Za-z]+Error:"
      - "catch\\s*\\(\\w+\\).*\\n(?:.*\\n){0,5}.*catch\\s*\\(\\w+\\)"

  - id: MECE-005
    name: copy_paste_code
    category: duplication
    severity: high
    description: "Detect copy-pasted code blocks"
    guidance: |
      Copy-paste is a maintenance burden:
      - Extract to functions
      - Use parameterization
      - Consider template patterns
    min_duplicate_lines: 5

  # Collective Exhaustiveness Violations (Gaps)
  - id: MECE-006
    name: missing_else_branch
    category: gap
    severity: medium
    description: "Detect if-elif chains without final else"
    guidance: |
      Cover all cases explicitly:
      - Add else branch even if just to raise
      - Document why certain cases are impossible
      - Use exhaustive pattern matching
    patterns:
      - "if.*:\\s*\\n.*elif.*:\\s*\\n(?!.*else:)"
      - "if\\s*\\(.*\\)\\s*\\{.*\\}\\s*else\\s+if\\s*\\(.*\\)\\s*\\{(?!.*\\}\\s*else\\s*\\{)"

  - id: MECE-007
    name: incomplete_enum_handling
    category: gap
    severity: high
    description: "Detect switch/match statements not handling all enum values"
    guidance: |
      Handle all enum cases:
      - Use match with _ default
      - Add explicit handling for each value
      - Consider structural pattern matching
    patterns:
      - "match\\s+[a-z_]+:"
      - "switch\\s*\\(\\w+\\)\\s*\\{"

  - id: MECE-008
    name: missing_null_check
    category: gap
    severity: high
    description: "Detect potential null/None access without checks"
    guidance: |
      Handle None cases explicitly:
      - Use Optional type hints
      - Add None checks before access
      - Consider using get() with defaults
    patterns:
      - "(?:result|response|data)\\[['\"]\\w+['\"]\\].*(?:result|response|data)\\[['\"]\\w+['\"]\\]"

  - id: MECE-009
    name: boundary_gaps
    category: gap
    severity: high
    description: "Detect gaps in numeric boundary conditions"
    guidance: |
      Ensure ranges are collectively exhaustive:
      - Use < and >= pairs (no gaps)
      - Document boundary values
      - Add assertions for expected ranges
    patterns:
      - "if.*<.*:\\s*\\n.*if.*>.*:"

  - id: MECE-010
    name: missing_default_case
    category: gap
    severity: medium
    description: "Detect dict.get() without default or missing KeyError handling"
    guidance: |
      Handle missing keys explicitly:
      - Always provide defaults for get()
      - Use defaultdict for known patterns
      - Catch KeyError where appropriate
    patterns:
      - "(?:config|settings|params|options)\\[['\"][a-z_]+['\"]\\]"

  # Structural Analysis
  - id: MECE-011
    name: parallel_structures
    category: structure
    severity: low
    description: "Detect parallel code structures that could be unified"
    guidance: |
      Parallel structures indicate opportunities:
      - Similar function signatures
      - Matching parameter patterns
      - Consider Strategy pattern
    min_parallel_functions: 3

  - id: MECE-012
    name: scattered_constants
    category: structure
    severity: medium
    description: "Detect related constants scattered across files"
    guidance: |
      Group related constants:
      - Use enums for related values
      - Create constants modules
      - Document relationships
    patterns:
      - "^\\s*(?:export\\s+)?(?:const|let|var)\\s+[A-Z][A-Z_]{2,}\\s*=\\s*[0-9]+"

