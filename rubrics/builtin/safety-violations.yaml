# Safety Violations Rubric
# Detecting dangerous code patterns and anti-patterns
#
# Categories:
# - God Objects: Classes that know/do too much
# - Parameter Bombs: Functions with too many parameters
# - Dependency Hell: Circular or excessive dependencies
# - Resource Leaks: Unmanaged resources
# - Security Anti-patterns: Common vulnerability patterns

name: safety-violations
version: "1.0"
description: "Detect dangerous code patterns: god objects, parameter bombs, and critical violations"

thresholds:
  max_critical_violations: 0
  max_high_violations: 5
  max_medium_violations: 20

rules:
  # God Object Detection
  - id: SAF-001
    name: god_class
    category: god_object
    severity: critical
    description: "Classes with too many methods or responsibilities"
    guidance: |
      God classes violate Single Responsibility:
      - Maximum 20 public methods
      - Maximum 500 lines
      - Split into focused classes
      - Use composition over inheritance
    thresholds:
      max_methods: 20
      max_lines: 500
      max_instance_variables: 15

  - id: SAF-002
    name: god_method
    category: god_object
    severity: high
    description: "Methods that do too many things"
    guidance: |
      God methods are hard to test/maintain:
      - Maximum 50 lines
      - Maximum cyclomatic complexity 15
      - Extract sub-methods
      - Single level of abstraction
    thresholds:
      max_lines: 50
      max_complexity: 15

  - id: SAF-003
    name: omniscient_module
    category: god_object
    severity: high
    description: "Modules that import too many dependencies"
    guidance: |
      High fan-in indicates poor cohesion:
      - Maximum 10 imports
      - Group related imports
      - Consider facade pattern
      - Split into sub-modules
    thresholds:
      max_imports: 10
    patterns:
      - "^from\\s+\\S+\\s+import\\s+.{100,}"
      - "^import\\s+\\S+,\\s*\\S+,\\s*\\S+,\\s*\\S+,\\s*\\S+,\\s*\\S+,\\s*\\S+,\\s*\\S+,\\s*\\S+,\\s*\\S+"
      - "^import\\s+\\{.{100,}\\}\\s+from"

  # Parameter Bomb Detection
  - id: SAF-004
    name: parameter_bomb
    category: parameter_bomb
    severity: high
    description: "Functions with too many parameters"
    guidance: |
      Many parameters indicate poor design:
      - Maximum 5 parameters (ideal: 3)
      - Use parameter objects
      - Use builder pattern
      - Consider default values
    thresholds:
      max_parameters: 5
      warning_parameters: 4
    patterns:
      - "def\\s+[a-z_]+\\([^)]{400,}\\)"
      - "function\\s+\\w+\\([^)]{200,}\\)"
      - "\\w+\\s*\\([^)]{200,}\\)\\s*[:{=>]"

  - id: SAF-005
    name: boolean_parameter_overload
    category: parameter_bomb
    severity: medium
    description: "Functions with multiple boolean flags"
    guidance: |
      Boolean flags obscure intent:
      - Maximum 1 boolean parameter
      - Use enum instead of booleans
      - Split into separate functions
      - Use keyword arguments
    patterns:
      - "def\\s+\\w+\\(.*:\\s*bool.*:\\s*bool.*:\\s*bool"
      - "\\w+:\\s*boolean.*\\w+:\\s*boolean.*\\w+:\\s*boolean"

  - id: SAF-006
    name: positional_only_params
    category: parameter_bomb
    severity: medium
    description: "Long functions relying on positional parameters only"
    guidance: |
      Positional params are error-prone:
      - Use keyword arguments
      - Use dataclasses for related params
      - Document parameter order
      - Add type hints
    patterns:
      - "def\\s+[a-z_]+\\([a-z_]+,\\s*[a-z_]+,\\s*[a-z_]+,\\s*[a-z_]+,"
      - "function\\s+\\w+\\(\\w+,\\s*\\w+,\\s*\\w+,\\s*\\w+,"

  # Dependency Hell
  - id: SAF-007
    name: circular_import
    category: dependency
    severity: critical
    description: "Circular import dependencies"
    guidance: |
      Circular imports cause:
      - Import errors at runtime
      - Hard to understand flow
      - Tight coupling
      - Use dependency injection
      - Restructure modules
    patterns:
      - "# type:\\s*ignore.*import"
      - "@ts-ignore"
      - "@ts-expect-error"
      - "// eslint-disable"

  - id: SAF-008
    name: deep_import_chain
    category: dependency
    severity: high
    description: "Imports with deep module paths"
    guidance: |
      Deep imports indicate poor API:
      - Maximum 3 levels deep
      - Use __init__.py exports
      - Create facade modules
      - Hide implementation details
    patterns:
      - "from\\s+[a-z_]+\\.[a-z_]+\\.[a-z_]+\\.[a-z_]+\\s+import"
      - "from\\s+['\"][^'\"]+/[^'\"]+/[^'\"]+/[^'\"]+['\"]"
      - "require\\(['\"][^'\"]+/[^'\"]+/[^'\"]+/[^'\"]+['\"]\\)"
    max_depth: 3

  - id: SAF-009
    name: hidden_dependencies
    category: dependency
    severity: high
    description: "Dependencies injected via global state or singletons"
    guidance: |
      Hidden dependencies are hard to test:
      - Use explicit dependency injection
      - Avoid global state
      - Pass dependencies as parameters
      - Use factories
    patterns:
      - "global\\s+[a-z_]+"
      - "\\.getInstance\\(\\)"
      - "_instance\\s*="
      - "\\bglobalThis\\."
      - "\\bwindow\\.\\w+\\s*="

  # Resource Leak Detection
  - id: SAF-010
    name: unclosed_resources
    category: resource_leak
    severity: critical
    description: "Resources opened but not closed"
    guidance: |
      Always close resources:
      - Use context managers (with)
      - Use try/finally
      - Implement __enter__/__exit__
      - Use atexit for cleanup
    patterns:
      - "^\\s*\\w+\\s*=\\s*open\\([^)]+\\)(?!.*close)"
      - "^\\s*\\w+\\s*=\\s*\\w+\\.connect\\([^)]+\\)(?!.*close)"
      - "^\\s*\\w+\\s*=\\s*socket\\.socket\\([^)]+\\)(?!.*close)"

  - id: SAF-011
    name: missing_context_manager
    category: resource_leak
    severity: high
    description: "File/connection operations without context manager"
    guidance: |
      Use context managers for:
      - File operations
      - Database connections
      - Network sockets
      - Lock acquisition
    patterns:
      - "^\\s*f\\s*=\\s*open\\("
      - "^\\s*conn\\s*=\\s*.*connect\\("
      - "^\\s*cursor\\s*=\\s*.*cursor\\("

  # Security Anti-patterns
  - id: SAF-012
    name: hardcoded_secrets
    category: security
    severity: critical
    description: "Credentials or secrets hardcoded in source"
    guidance: |
      Never hardcode secrets:
      - Use environment variables
      - Use secret managers
      - Use configuration files (gitignored)
      - Rotate compromised secrets
    patterns:
      - "password\\s*=\\s*['\"][^'\"]{8,}['\"]"
      - "token\\s*=\\s*['\"][A-Za-z0-9]{32,}['\"]"
      - "password\\s*:\\s*['\"][^'\"]{8,}['\"]"
      - "(?:secret|apiKey|api_key)\\s*[=:]\\s*['\"][^'\"]{8,}['\"]"

  - id: SAF-013
    name: sql_injection_risk
    category: security
    severity: critical
    description: "String formatting in SQL queries"
    guidance: |
      Use parameterized queries:
      - Never use f-strings for SQL
      - Never use .format() for SQL
      - Use query parameters
      - Use ORM when possible
    patterns:
      - "execute\\(f['\"]"
      - "execute\\(['\"].*%s"
      - "execute\\(['\"].*\\.format"

  - id: SAF-014
    name: command_injection_risk
    category: security
    severity: critical
    description: "Unescaped user input in shell commands"
    guidance: |
      Avoid shell injection:
      - Use subprocess with list args
      - Never use shell=True with user input
      - Validate/sanitize all input
      - Use shlex.quote()
    patterns:
      - "os\\.system\\("
      - "subprocess.*shell\\s*=\\s*True"
      - "exec\\("
      - "eval\\("

  - id: SAF-015
    name: unsafe_deserialization
    category: security
    severity: critical
    description: "Unsafe pickle or yaml loading"
    guidance: |
      Deserialization is dangerous:
      - Never unpickle untrusted data
      - Use yaml.safe_load()
      - Prefer JSON for serialization
      - Validate before deserializing
    patterns:
      - "pickle\\.loads?\\("
      - "yaml\\.load\\([^,)]+\\)(?!.*Loader)"
      - "yaml\\.load\\([^,)]+,\\s*Loader\\s*=\\s*yaml\\.FullLoader"

  # Error Handling Anti-patterns
  - id: SAF-016
    name: bare_except
    category: error_handling
    severity: high
    description: "Catching all exceptions without specificity"
    guidance: |
      Catch specific exceptions:
      - Never use bare except:
      - Catch Exception, not BaseException
      - Log before re-raising
      - Don't swallow exceptions
    patterns:
      - "except:"
      - "except\\s+BaseException"
      - "catch\\s*\\(\\s*\\w*\\s*\\)\\s*\\{"
      - "catch\\s*\\{\\s*\\}"

  - id: SAF-017
    name: exception_swallowing
    category: error_handling
    severity: critical
    description: "Catching exceptions and doing nothing"
    guidance: |
      Handle exceptions properly:
      - Always log exceptions
      - Re-raise if can't handle
      - Return error indicators
      - Never pass silently
    patterns:
      - "except.*:\\s*\\n\\s*pass"
      - "except.*:\\s*\\n\\s*\\.\\.\\.s*\\n"
      - "catch\\s*\\([^)]*\\)\\s*\\{\\s*\\}"
      - "catch\\s*\\([^)]*\\)\\s*\\{\\s*//.*\\s*\\}"

  # Thread Safety
  - id: SAF-018
    name: race_condition_risk
    category: concurrency
    severity: high
    description: "Shared mutable state without synchronization"
    guidance: |
      Protect shared state:
      - Use locks for mutable state
      - Prefer immutable data
      - Use thread-local storage
      - Use atomic operations
    patterns:
      - "threading\\.Thread.*target.*global"
      - "shared_[a-z_]+\\s*="

